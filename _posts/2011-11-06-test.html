<!DOCTYPE html>
<html lang="ko-KR">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>처음 만나는 코루틴 | 코틀린 코루틴 예제</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="처음 만나는 코루틴" />
<meta property="og:locale" content="ko_KR" />
<link rel="canonical" href="https://dalinaum.github.io/coroutines-example/1.html" />
<meta property="og:url" content="https://dalinaum.github.io/coroutines-example/1.html" />
<meta property="og:site_name" content="코틀린 코루틴 예제" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="처음 만나는 코루틴" />
<script type="application/ld+json">
{"url":"https://dalinaum.github.io/coroutines-example/1.html","@type":"WebPage","headline":"처음 만나는 코루틴","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style" type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/coroutines-example/assets/css/style.css?v=c11fcb4c16c8de888134c27bd2961c3f7a854893">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/coroutines-example/favicon.ico" -->

<script src="https://unpkg.com/kotlin-playground@1" data-selector=".kotlin-playground"></script>
<!-- end custom head snippets -->


  </head>
  <body>
    <a id="skip-to-content" href="#content">Skip to the content.</a>

    <header class="page-header" role="banner">
      <h1 class="project-name">처음 만나는 코루틴</h1>
      <h2 class="project-tagline"></h2>
    </header>

    <main id="content" class="main-content" role="main">
      <h2 id="처음-만나는-코루틴">처음 만나는 코루틴</h2>

<h3 id="예제-1-간단한-코루틴">예제 1: 간단한 코루틴</h3>

<p>아주 간단한 코루틴을 수행해봅시다.
코루틴을 만드는 가장 간단한 함수는 <code class="language-plaintext highlighter-rouge">runBlocking</code>이라고 합니다. 이렇게 코루틴을 만드는 함수를 코루틴 빌더라고 합니다. <code class="language-plaintext highlighter-rouge">runBlocking</code>은 코루틴을 만들고 코드 블록이 수행이 끝날 때까지 <code class="language-plaintext highlighter-rouge">runBlocking</code> 다음의 코드를 수행하지 못하게 막습니다. 그래서 블로킹(blocking)인거죠.</p>

<div class="kotlin-playground">
import kotlinx.coroutines.*

fun main() = runBlocking {
    println(Thread.currentThread().name)
    println("Hello")
}
</div>

<p>스레드 이름이 <code class="language-plaintext highlighter-rouge">main @coroutine1</code>입니다.</p>

<p>메인 스레드에서 수행되는데 뒤에 수식어 <code class="language-plaintext highlighter-rouge">@coroutine1</code>이 붙어 있습니다.</p>

<h3 id="예제-2-코루틴-빌더의-수신-객체">예제 2: 코루틴 빌더의 수신 객체</h3>

<p><code class="language-plaintext highlighter-rouge">runBlocking</code>안에서 <code class="language-plaintext highlighter-rouge">this</code>를 수행하면 코루틴이 수신 객체(Receiver)인 것을 알 수 있습니다.</p>

<div class="kotlin-playground">
import kotlinx.coroutines.*

fun main() = runBlocking {
    println(this)
    println(Thread.currentThread().name)
    println("Hello")
}
</div>

<p><code class="language-plaintext highlighter-rouge">"coroutine#1":BlockingCoroutine{Active}@3930015a</code> 이런 형태의 결과가 나옵니다.</p>

<p><code class="language-plaintext highlighter-rouge">BlockingCoroutine</code>은 <code class="language-plaintext highlighter-rouge">CoroutineScope</code>의 자식입니다. 코틀린 코루틴을 쓰는 모든 곳에는 코루틴 스코프(<code class="language-plaintext highlighter-rouge">CoroutineScope</code>)가 있다고 생각하면 됩니다.</p>

<p>코루틴의 시작은 코루틴 스코프다. 외웁시다.</p>

<h3 id="예제-3-코루틴-컨텍스트">예제 3: 코루틴 컨텍스트</h3>

<p>코루틴 스코프는 코루틴을 제대로 처리하기 위한 정보, 코루틴 컨텍스트(<code class="language-plaintext highlighter-rouge">CoroutineContext</code>)를 가지고 있습니다. 수신 객체의 <code class="language-plaintext highlighter-rouge">coroutineContext</code>를 호출해 내용을 확인해봅시다.</p>

<div class="kotlin-playground">
import kotlinx.coroutines.*

fun main() = runBlocking {
    println(coroutineContext)
    println(Thread.currentThread().name)
    println("Hello")
}
</div>

<h3 id="예제-4-launch-코루틴-빌더">예제 4: launch 코루틴 빌더</h3>

<p>이제 코루틴 내에서 다른 코루틴을 수행해 봅시다.</p>

<p>이번에는 <code class="language-plaintext highlighter-rouge">launch</code>란 빌더를 사용해서 코드를 수행합니다. <code class="language-plaintext highlighter-rouge">launch</code>는 코루틴 빌더입니다. 새로운 코루틴을 만들기 때문에 새로운 코루틴 스코프를 만들게 되고요. <code class="language-plaintext highlighter-rouge">launch</code>는 “할 수 있다면 다른 코루틴 코드를 같이 수행”시키는 코루틴 빌더입니다.</p>

<div class="kotlin-playground">
import kotlinx.coroutines.*

fun main() = runBlocking {
    launch {
        println("launch: ${Thread.currentThread().name}")
        println("World!")
    }
    println("runBlocking: ${Thread.currentThread().name}")
    println("Hello")
}
</div>

<p><code class="language-plaintext highlighter-rouge">launch</code> 코루틴 빌더에 있는 내용이 <code class="language-plaintext highlighter-rouge">runBlocking</code>이 있는 메인 흐름 보다 늦게 수행된 것을 볼 수 있습니다. 둘 다 메인 스레드(<code class="language-plaintext highlighter-rouge">main</code>)를 사용하기 때문에 <code class="language-plaintext highlighter-rouge">runBlocking</code>의 코드들이 메인 스레드를 다 사용할 때 까지 <code class="language-plaintext highlighter-rouge">launch</code>의 코드 블록이 기다리는 것입니다.</p>

<p><code class="language-plaintext highlighter-rouge">launch</code>를 이용해 동시에 여러 코드를 수행하는 것은 다음에 다루겠습니다.</p>

<p><code class="language-plaintext highlighter-rouge">runBlocking</code>은 <code class="language-plaintext highlighter-rouge">Hello</code>를 출력하고 나서 종료하지는 않고 <code class="language-plaintext highlighter-rouge">launch</code> 코드블록의 내용이 다 끝날 때까지 기다립니다.</p>

<h3 id="예제-5-delay-함수">예제 5: delay 함수</h3>

<p>Hello를 조금 더 늦게 수행시키기 위해서는 <code class="language-plaintext highlighter-rouge">delay</code> 함수를 호출해 봅시다. 인자로 밀리세컨드 단위의 시간을 지정할 수 있습니다.</p>

<div class="kotlin-playground">
import kotlinx.coroutines.*

fun main() = runBlocking {
    launch {
        println("launch: ${Thread.currentThread().name}")
        println("World!")
    }
    println("runBlocking: ${Thread.currentThread().name}")
    delay(500L)
    println("Hello")
}
</div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">println</span><span class="p">(</span><span class="s">"runBlocking: ${Thread.currentThread().name}"</span><span class="p">)</span>
<span class="nf">delay</span><span class="p">(</span><span class="mi">500L</span><span class="p">)</span>
</code></pre></div></div>

<p>프린트 문이 호출된 이후 <code class="language-plaintext highlighter-rouge">delay</code>가 호출되는데 이때 <code class="language-plaintext highlighter-rouge">runBlocking</code>의 코루틴이 잠이 들게 되고 <code class="language-plaintext highlighter-rouge">launch</code>의 코드 블록이 먼저 수행됩니다.</p>

<h3 id="예제-6-코루틴-내에서-sleep">예제 6: 코루틴 내에서 sleep</h3>

<p>우리가 잘 아는 <code class="language-plaintext highlighter-rouge">Thread.sleep</code>을 호출하면 어떻게 될까요?</p>

<div class="kotlin-playground">
import kotlinx.coroutines.*

fun main() = runBlocking {
    launch {
        println("launch: ${Thread.currentThread().name}")
        println("World!")
    }
    println("runBlocking: ${Thread.currentThread().name}")
    Thread.sleep(500)
    println("Hello")
}
</div>

<p>우리가 원하는 결과가 나오지 않았을 것입니다. <code class="language-plaintext highlighter-rouge">Thread.sleep</code>을 하면 코루틴이 아무 일을 하지 않는 동안에도 스레드를 양보하지 않고 독점합니다.</p>

<h3 id="예제-7-한번에-여러-launch">예제 7: 한번에 여러 launch</h3>

<p>1, 2, 3을 순서대로 수행시켜봅시다.</p>

<div class="kotlin-playground">
import kotlinx.coroutines.*

fun main() = runBlocking {
    launch {
        println("launch1: ${Thread.currentThread().name}")
        delay(1000L)
        println("3!")
    }
    launch {
        println("launch2: ${Thread.currentThread().name}")
        println("1!")
    }
    println("runBlocking: ${Thread.currentThread().name}")
    delay(500L)
    println("2!")
}
</div>

<p>딜레이 값을 바꿔 보면 <code class="language-plaintext highlighter-rouge">suspend</code>된 이후 깨어나는 순서에 따라 출력 결과가 달라집니다.</p>

<h3 id="예제-8-상위-코루틴은-하위-코루틴을-끝까지-책임진다">예제 8: 상위 코루틴은 하위 코루틴을 끝까지 책임진다.</h3>

<p><code class="language-plaintext highlighter-rouge">runBlocking</code> 안에 두 <code class="language-plaintext highlighter-rouge">launch</code>가 속해 있는데 계층화되어 있어 구조적입니다. <code class="language-plaintext highlighter-rouge">runBlocking</code>은 그 속에 포함된 <code class="language-plaintext highlighter-rouge">launch</code>가 다 끝나기 전까지 종료되지 않습니다.</p>

<div class="kotlin-playground">
import kotlinx.coroutines.*

fun main() {
    runBlocking {
        launch {
            println("launch1: ${Thread.currentThread().name}")
            delay(1000L)
            println("3!")
        }
        launch {
            println("launch2: ${Thread.currentThread().name}")
            println("1!")
        }
        println("runBlocking: ${Thread.currentThread().name}")
        delay(500L)
        println("2!")
    }
    print("4!")
}
</div>

<h3 id="예제-9-suspend-함수">예제 9: suspend 함수</h3>

<p><code class="language-plaintext highlighter-rouge">delay</code>, <code class="language-plaintext highlighter-rouge">launch</code> 등 지금까지 봤던 함수들은 코루틴 내에서만 호출 할 수 있습니다. 그럼 이 함수들을 포함한 코드들을 어떻게 함수로 분리할 수 있을까요?</p>

<p>코드의 일부를 함수로 분리할 때는 함수의 앞에 <code class="language-plaintext highlighter-rouge">suspend</code> 키워드를 붙이면 됩니다.</p>

<div class="kotlin-playground">
import kotlinx.coroutines.*

suspend fun doThree() {
    println("launch1: ${Thread.currentThread().name}")
    delay(1000L)
    println("3!")
}

suspend fun doOne() {
    println("launch1: ${Thread.currentThread().name}")
    println("1!")
}

suspend fun doTwo() {
    println("runBlocking: ${Thread.currentThread().name}")
    delay(500L)
    println("2!")
}

fun main() = runBlocking {
    launch {
        doThree()
    }
    launch {
        doOne()
    }
    doTwo()
}
</div>

<p><code class="language-plaintext highlighter-rouge">doOne</code>은 <code class="language-plaintext highlighter-rouge">delay</code>와 같은 함수(<code class="language-plaintext highlighter-rouge">suspend</code>인 함수)를 호출하지 않았기 때문에 <code class="language-plaintext highlighter-rouge">suspend</code>를 붙이지 않은 일반 함수로 해도 됩니다.</p>

<p>만약 <code class="language-plaintext highlighter-rouge">suspend</code> 함수를 다른 함수에서 호출하려면 그 함수가 <code class="language-plaintext highlighter-rouge">suspend</code> 함수이거나 코루틴 빌더를 통해 코루틴을 만들어야 합니다.</p>


      <footer class="site-footer">
        <span class="site-footer-credits">This page was generated by <a href="https://jekyllrb.com/">Jekyll</a>.</span>
      </footer>
    </main>
  </body>
</html>
